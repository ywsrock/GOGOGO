# TCPで大きなファイルをStreamで処理

このプログラムは、TCP接続を介してデータを送受信するサンプルサーバとクライアントを実装しています。サーバはポート3000でリスニングし、クライアントはランダムなデータを生成してサーバに送信します。

## 構造

### `tcpServer` 

この構造体は、ファイルサーバを表します。

#### `open()`

- ポート `3000` でTCPリスナーを開始します。
- 新しい接続が確立されるたびに、`readLoop` メソッドをゴルーチンで実行して接続を処理します。

#### `handle(conn net.Conn)`

- 受信データを保持するためのバッファを作成します。
- 接続からファイルのサイズを読み取ります。
- ファイルのデータをバッファに読み込みます。
- 受信したバイト数と実際のバイトを表示します。

### `send(size int)`

- 指定されたサイズのバイトスライスを作成し、ランダムなデータでそれを埋めます。
- サーバにTCP接続を確立します。
- ファイルのサイズをサーバに送信します。
- 実際のファイルデータをサーバに送信します。

## 実行

`main` 関数を実行すると、次のことが行われます：

1. 4秒待機した後、サイズが100のランダムなデータをサーバに送信するゴルーチンが開始されます。
2. `fileServer` の `start` メソッドを呼び出して、サーバを開始します。


## `binary.Write`

**概要**:
`binary.Write` は、指定されたデータをバイナリエンコードして、指定された `io.Writer` インターフェースに書き込みます。

**シグネチャ**:
```go
func Write(w io.Writer, order ByteOrder, data interface{}) error
```

**パラメータ**:
- `w`: データの書き込み先。通常、ファイルやネットワーク接続などのIOリソースです。
- `order`: バイトオーダー (エンディアン) を指定します。通常、`binary.BigEndian` または `binary.LittleEndian` を使用します。
- `data`: 書き込むデータ。固定サイズの値や固定サイズの配列でなければなりません。

---
もちろんです。以下は、`binary.Write`と`binary.Read`に関する情報をまとめたMarkdown文書です。

---

## Goの `encoding/binary` パッケージについて

Go言語の `encoding/binary` パッケージは、データをバイナリ形式でエンコードおよびデコードするための機能を提供します。特に、`binary.Write` と `binary.Read` の2つの関数はこのパッケージの中心的な部分です。

### `binary.Write`

- **目的**: 指定されたデータをバイナリエンコードし、`io.Writer` インターフェースに書き込む。
  
- **関数の形**:
  ```go
  func Write(w io.Writer, order ByteOrder, data interface{}) error
  ```

- **主要な引数**:
  - `w`: 書き込み先のIOリソース。
  - `order`: バイトオーダー (`binary.BigEndian` または `binary.LittleEndian`)。
  - `data`: 書き込むデータ。固定サイズが必要。

### `binary.Read`

- **目的**: `io.Reader` からデータをバイナリ形式で読み込み、指定されたデータ型にデコードする。

- **関数の形**:
  ```go
  func Read(r io.Reader, order ByteOrder, data interface{}) error
  ```

- **主要な引数**:
  - `r`: 読み込み元のIOリソース。
  - `order`: バイトオーダー (`binary.BigEndian` または `binary.LittleEndian`)。
  - `data`: デコードされたデータの格納先。固定サイズが必要。

---

**注意事項**:
1. 固定サイズのデータ型のみがエンコード/デコード可能。可変サイズのデータは追加の処理が必要。
2. エンディアンの指定が必須。異なるエンディアンでのエンコードとデコードはデータの解釈エラーを引き起こす可能性がある。